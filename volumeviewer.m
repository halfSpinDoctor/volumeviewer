function varargout = volumeviewer(varargin)% VOLUMEVIEWER M-file for volumeviewer.fig% -------------------------------------------------------------------------% VOLUMEVIEWER is a tool for roi analysis of 3d (and 4d) arrays% type the name of a workspace variable into the 'variable name' field in% the gui% %% Usage:% VOLUMEVIEWER opens the tool% VOLUMEVIEWER('array') opens the tool with 'array' already loaded%% Created 10-24-06 Rafael O'Halloran% added window level 1-23-07 RO% lots of new stuff  6-23-07% Zoom!              7-16-07 % Added Log buttons, flip vertical/horizontal buttons, and 3 to 4 D% permutation.       2-15-08%%% To Do: Make compatible with new Matlab ROIPOLY ( the interactive one)% 2-15-08% -------------------------------------------------------------------------%% See also: GUIDE, GUIDATA, GUIHANDLES% Last Modified by GUIDE v2.5 15-Feb-2008 10:51:16% Begin initialization code - DO NOT EDITgui_Singleton = 1;gui_State = struct('gui_Name',       mfilename, 'gui_Singleton',  gui_Singleton, 'gui_OpeningFcn', @volumeviewer_OpeningFcn,    'gui_OutputFcn',  @volumeviewer_OutputFcn,  'gui_LayoutFcn',  [] ,  'gui_Callback',   []);if nargin & ischar(varargin{1})    gui_State.gui_Callback = str2func(varargin{1});endif nargout    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});else    gui_mainfcn(gui_State, varargin{:});end% End initialization code - DO NOT EDIT%--------------------------------------------------------------------------% Executes just before volumeviewer pops up%--------------------------------------------------------------------------function volumeviewer_OpeningFcn(hObject, eventdata, handles, varargin)% Choose default command line output for volumeviewerhandles.output = hObject;% define handleshandles.mask = 0;                   % mask for roi datahandles.perm = [1 2 3 4];             % permutation handlehandles.welcome = magic(10);        % initial image handleshandles.clim = [0 1];               % upper and lower colorbar handleshandles.axes2bit = 0;               % tells wether axes 2 is profile (1) or histo (0)% Update handles structureguidata(hObject, handles);% set background color%set(gcf,'Color',[130 130 130]./256); set(gcf,'Color',[232 243 255]./256);% set(gcf,'Color',[204 230 255]./256);%set(gcf,'Color',[.5 0 0]); % its red!%set initial imageif size(varargin) == 1;    set(handles.fig,'String',varargin{1});  else     %evalin('base','welcome = magic(10);');    set(handles.fig,'String','welcome');    set(handles.slice,'String','1');    set(handles.volume,'String','1');%     global nvols;endpushbutton1_Callback(hObject,eventdata,handles);axes(handles.axes2);box on;%--------------------------------------------------------------------------% Spits out default output%--------------------------------------------------------------------------function varargout = volumeviewer_OutputFcn(hObject, eventdata, handles)% Get default command line output from handles structurevarargout{1} = handles.output;%--------------------------------------------------------------------------% Executes during object creation, after setting all properties.%--------------------------------------------------------------------------function fig_CreateFcn(hObject, eventdata, handles)% Hint: edit controls usually have a white background, change%       'usewhitebg' to 0 to use default.  See ISPC and COMPUTER.usewhitebg = 1;if usewhitebg    set(hObject,'BackgroundColor','white');else    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));end%--------------------------------------------------------------------------% Executes when something is entered into data boxfunction fig_Callback(hObject, eventdata, handles)%--------------------------------------------------------------------------% get data saved as m filevar_name = (get(hObject, 'String'));data = evalin('base',var_name);% set aspect ratio to 1set(handles.aspectratio,'String','1');% set lockcolorbar to offset(handles.colorlock,'Value',0);% set permutation to [1 2 3]set(handles.permu,'Value',1);handles.perm = [1 2 3 4];guidata(hObject, handles);% set slice to 1set(handles.slice,'String','1');% set volume to 1set(handles.volume,'String','1');permu_Callback(hObject, eventdata, handles);pushbutton1_Callback(hObject,eventdata,handles);%--------------------------------------------------------------------------% --- Executes during object creation, after setting all properties.function slice_CreateFcn(hObject, eventdata, handles)%--------------------------------------------------------------------------usewhitebg = 1;if usewhitebg    set(hObject,'BackgroundColor','white');else    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));end%--------------------------------------------------------------------------% Executes when something is entered into 'slice' box%--------------------------------------------------------------------------function slice_Callback(hObject, eventdata, handles)slice = str2double(get(hObject, 'String'));pushbutton1_Callback(hObject, eventdata, handles)%--------------------------------------------------------------------------% GET image data function%**************************************************************************%**************************************************************************function [image_data varargout] = get_image_data(hObject, eventdata, handles)% Load Datavar_name = get(handles.fig, 'String');if strcmp(var_name,'welcome');    data = handles.welcome;else    data = double(evalin('base',var_name));end% % swap 3 and 4?% if get(handles.perm34,'Value') == 1%     data = permute(data,[1 2 4 3]);% end%permute dataperm = handles.perm;data = permute(data,perm);% get volumevolume=str2double(get(handles.volume,'String'));data = data(:,:,:,volume);% flipdimif get(handles.flip_vert,'Value') == 1    data = flipdim(data,1);endif get(handles.flip_hor,'Value') == 1    data = flipdim(data,2);end% do MIP if 'MIP' is checkedif get(handles.MIP,'Value') == 1    set(handles.slice,'String','1'); % set slice to 1    data = max(data,[],3);end% get total slices sizevarargout{1} = size(data,3);% z fourier transformif get(handles.zft,'Value') == 1    data = fft(data,[],3);end% z inverse fourier transformif get(handles.zift,'Value') == 1    data = ifft(data,[],3);end% z fft shiftif get(handles.zftshift,'Value') == 1    data = fftshift(data,3);end% define rgb image if checkedif get(handles.RGBcolor,'Value') == 1 & size(data,3)>2    slice = str2double(get(handles.slice,'String'));    if slice < size(data,3)-1        I = double(data(:,:,slice:slice+2));    else        I = double(data(:,:,size(data,3)-2:end));    end    %     if min(min(min(I))) < 0 | max(max(max(I))) > 1%         I = I - min(min(min(I)));%         I = I/max(max(max(I)));%     end    elseif get(handles.globalwl,'Value') == 0    % pick the slice    slice = str2double(get(handles.slice,'String'));    I = data(:,:,slice);else    I=data;end  % x and y fourier transform if get(handles.xft,'Value') == 1    I = fft(I,[],2);endif get(handles.yft,'Value') == 1    I = fft(I,[],1);end% x and y inverse fourier transform if get(handles.xift,'Value') == 1    I = ifft(I,[],2);endif get(handles.yift,'Value') == 1    I = ifft(I,[],1);end% x and y fft shiftif get(handles.xftshift,'Value') == 1    I = fftshift(I,2);endif get(handles.yftshift,'Value') == 1    I = fftshift(I,1);endmatrix = size(I,1);% radon transform at number of angles = number of columnsif get(handles.radon,'Value') == 1    for i = 1:size(I,3);        dummy(:,:,i) = radon(I(:,:,i),[1:size(I,2)]*180/size(I,2));    end    I = dummy; clear dummy;end% inverse radon transform at number of angles = number of columnsif get(handles.iradon,'Value') == 1    for i = 1:size(I,3)        dummy(:,:,i) = iradon(I(:,:,i),[1:size(I,2)]*180/size(I,2),'linear','Ram-Lak',1,matrix);    end    I = dummy; clear dummy;end% complex logif get(handles.comp_log,'Value') == 1    I = log(I);    I(find(isnan(I))) = 0;    I(find(isinf(I))) = 0;end% handle complex datan = get(handles.complexdata,'Value');if n == 1; I = real(I); endif n == 2; I = imag(I); endif n == 3; I = abs(I);  endif n == 4; I = angle(I)*180/pi;end;%atan(imag(I)./real(I))*180/pi; end% logif get(handles.natural_log,'Value') == 1    I(find(I>0)) = log(I(find(I>0)));    I(find(I<=0)) = 0;    I(find(isnan(I))) = 0;    I(find(isinf(I))) = 0;end% rescale data for rgb color if neededif get(handles.RGBcolor,'Value') == 1 & size(data,3)>2    if min(min(min(I))) < 0 | max(max(max(I))) > 1        I = I - min(min(min(I)));        I = I/max(max(max(I)));    end   end% Global Window/Levelif get(handles.globalwl,'Value') == 1    clims(1) = min(min(min(I)));    clims(2) = max(max(max(I)));    set(handles.clim1,'String',num2str(clims(1)));    set(handles.clim2,'String',num2str(clims(2)));    slice = str2double(get(handles.slice,'String'));    I = I(:,:,slice);endimage_data = I;%**************************************************************************%**************************************************************************% DISPLAY IMAGE%**************************************************************************%**************************************************************************function pushbutton1_Callback(hObject, eventdata, handles)% This executes when you push the 'display image' button% It also calculates new roi parameters if the 'keepROI' box is checked% get the image data[I total_slices] = get_image_data(hObject, eventdata, handles);% clear whatever is in the windowaxes(handles.axes1);cla;% display image and select colormap from dropdown menucontents = get(handles.popupmenu1,'String');map = contents{get(handles.popupmenu1,'Value')};% get color limits and set clim boxes if colorlock is offif get(handles.colorlock,'Value') == 0 && get(handles.globalwl,'Value')==0;    clims(1) = min(min(I(:,:,1)));    clims(2) = max(max(I(:,:,1)));    if clims(1)==clims(2)        clims(2)=clims(1)+1;    end    set(handles.clim1,'String',num2str(clims(1)));    set(handles.clim2,'String',num2str(clims(2)));end% set global Window/Levelif get(handles.globalwl,'Value')==1    clims(1) = str2num(get(handles.clim1,'String'));    clims(2) = str2num(get(handles.clim2,'String'));end% set color limits if colorlock is onif get(handles.colorlock,'Value') == 1;    clims(1) = str2num(get(handles.clim1,'String'));    clims(2) = str2num(get(handles.clim2,'String'));end% if window and level is onif get(handles.window_level,'Value') == 1    imagesc_wl(I,[clims(1) clims(2)]); axis tight; axis off; %axis image; elseif get(handles.RGBcolor,'Value') == 1 & total_slices>2    image(I);  axis tight; axis off;else    imagesc(I,[clims(1) clims(2)]); axis tight; axis off; %axis image; endcolorbar_handle = colorbar('SouthOutside');set(colorbar_handle,'Xcolor','k','Ycolor','k','LineWidth',1,'FontSize',12);set(colorbar_handle,'Position',[0.03 0.09 .5 .05]);daspect([str2num(get(handles.aspectratio,'String')) 1 1]);% calculate new roi data if 'keepROI' box is checkedif get(handles.keepROI,'Value') == 1    mask = handles.mask;    me = num2str(mean(mean(I(mask))));    sdev = num2str(std(I(mask)));    set(handles.stdev, 'String', sdev);    set(handles.mea, 'String', me);    axes(handles.axes2);    hold on;    hist(I(mask),50);    axes(handles.axes1);end%**************************************************************************%**************************************************************************% SELECT ROI BUTTON%**************************************************************************%**************************************************************************function mask = pushbutton2_Callback(hObject, eventdata, handles)% This executes when you push the 'select roi' buttonhandles.axes2bit = 0;guidata(hObject, handles);% get the image dataI = get_image_data(hObject, eventdata, handles);% Load figure dataaxes(handles.axes1);var_name = get(handles.fig, 'String');if strcmp(var_name,'welcome');    data = handles.welcome;else    data = evalin('base',var_name);end% get the mask of ones defining the ROImask = roipoly_old;% Exclude Zero values if checkbox is onif get(handles.checkbox1,'Value') == 1    maskset = find(mask.*I ~= 0);else    maskset = find(mask > 0);end% set handles.mask as mask and save it so we can use it in other functions% specifically if keepROI is pressed we'll need to retain the ROI so that% when the user pushes display image the same ROI can be used to calculate% std and meanhandles.mask = mask;guidata(hObject, handles);% Calculate std and meanme = num2str(mean(mean(I(maskset))));sdev = num2str(std(I(maskset)));set(handles.stdev, 'String', sdev);set(handles.mea, 'String', me);% Plot the histogramaxes(handles.axes2);hold on; box on;hist(I(maskset),50);% Return to image as active axes set (for roiploy call later)axes(handles.axes1);%**************************************************************************%**************************************************************************% --- Executes during object creation, after setting all properties.function mea_CreateFcn(hObject, eventdata, handles)%--------------------------------------------------------------------------if ispc    set(hObject,'BackgroundColor','white');else    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));end%--------------------------------------------------------------------------%--------------------------------------------------------------------------function mea_Callback(hObject, eventdata, handles)%--------------------------------------------------------------------------% --- Executes during object creation, after setting all properties.function stdev_CreateFcn(hObject, eventdata, handles)%--------------------------------------------------------------------------if ispc    set(hObject,'BackgroundColor','white');else    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));end%--------------------------------------------------------------------------%--------------------------------------------------------------------------function stdev_Callback(hObject, eventdata, handles)%--------------------------------------------------------------------------% --- Executes on button press in checkbox1.%--------------------------------------------------------------------------function checkbox1_Callback(hObject, eventdata, handles)%--------------------------------------------------------------------------% --- Executes during object creation, after setting all properties.function popupmenu1_CreateFcn(hObject, eventdata, handles)%--------------------------------------------------------------------------if ispc    set(hObject,'BackgroundColor','white');else    set(hObject,'BackgroundColor',get(0,'defaultUicontrolBackgroundColor'));end%--------------------------------------------------------------------------% Changes color map when new one is selected from menufunction popupmenu1_Callback(hObject, eventdata, handles)%--------------------------------------------------------------------------axes(handles.axes1);%contents = get(hObject,'String')%map = contents{get(hObject,'Value')}contents = get(handles.popupmenu1,'String');map = contents{get(handles.popupmenu1,'Value')};% handle negative and invert if get(handles.neg,'Value') == 1 && get(handles.Invert,'Value') == 1    eval(['colormap(flipdim(abs(', map , '-1),1))']);elseif get(handles.neg,'Value') == 1    eval(['colormap(abs(', map , '-1))']);elseif get(handles.Invert,'Value') == 1    eval(['colormap(flipdim(',map,',1))']);else    eval(['colormap(',map,')']);end%--------------------------------------------------------------------------% --- Executes on button press in keepROI.%--------------------------------------------------------------------------function keepROI_Callback(hObject, eventdata, handles)%--------------------------------------------------------------------------% --- Cue Slice Down.%--------------------------------------------------------------------------function slice_down_Callback(hObject, eventdata, handles)current_slice = str2num(get(handles.slice,'String'));next_slice = (current_slice - 1);if next_slice > 0    set(handles.slice,'String',num2str(next_slice));    pushbutton1_Callback(hObject,eventdata,handles);end%--------------------------------------------------------------------------% -- Cue Slice Up%--------------------------------------------------------------------------function slice_up_Callback(hObject, eventdata, handles)current_slice = str2num(get(handles.slice,'String'));next_slice = (current_slice + 1);%perm = evalin('base','perm');perm = handles.perm;% load in size of data array and handle 2d caseif strcmp(get(handles.fig,'String'),'welcome');    array_size = [10 10 1];else    array_size = evalin('base',['size(' get(handles.fig,'String') ');']);endif size(array_size) < 3    array_size(3) = 1;end% calculate biggest slicemax_slice = array_size(perm(3));if next_slice <= max_slice    set(handles.slice,'String',num2str(next_slice));    pushbutton1_Callback(hObject,eventdata,handles);end%--------------------------------------------------------------------------% -Permutations of array indices% -------------------------------------------------------------------------function perm = permu_Callback(hObject, eventdata, handles)%--------------------------------------------------------------------------% 1 -> [1 2 3]% 2 -> [1 3 2]% 3 -> [2 1 3]% 4 -> [2 3 1]% 5 -> [3 1 2]% 6 -> [3 2 1]n = get(hObject,'Value');handles.perm = [1 2 3 4];if n == 1; %evalin('base','perm = [1 2 3];');     handles.perm = [1 2 3 4];endif n == 2; %evalin('base','perm = [1 3 2];');     handles.perm = [1 3 2 4];endif n == 3; %evalin('base','perm = [2 1 3];');     handles.perm = [2 1 3 4];endif n == 4; %evalin('base','perm = [2 3 1];');     handles.perm = [2 3 1 4];endif n == 5; %evalin('base','perm = [3 1 2];');     handles.perm = [3 1 2 4];endif n == 6; %evalin('base','perm = [3 2 1];');     handles.perm = [3 2 1 4];end% swap 3 and 4?if get(handles.perm34,'Value') == 1        ind3 = find(handles.perm == 3)    ind4 = find(handles.perm == 4)    dummy = handles.perm;    dummy(ind3) = 4; dummy(ind4) = 3;    handles.perm = dummy;      end% bump slice and vol back to 1set(handles.slice,'String','1')set(handles.volume,'String','1')guidata(hObject, handles);pushbutton1_Callback(hObject,eventdata,handles);%--------------------------------------------------------------------------% permutation (create)% -------------------------------------------------------------------------function permu_CreateFcn(hObject, eventdata, handles)%evalin('base','perm = [1 2 3];');handles.perm = [1 2 3 4];if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))    set(hObject,'BackgroundColor','white');end% -------------------------------------------------------------------------% Aspect Ratio% -------------------------------------------------------------------------function aspectratio_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% -------------------------------------------------------------------------% Aspect Ratio (create)% -------------------------------------------------------------------------function aspectratio_CreateFcn(hObject, eventdata, handles)if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))    set(hObject,'BackgroundColor','white');end% -------------------------------------------------------------------------% --- Executes on selection change in complexdata.function complexdata_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% --- Executes during object creation, after setting all properties.% -------------------------------------------------------------------------% Makes the background whitefunction complexdata_CreateFcn(hObject, eventdata, handles)if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))    set(hObject,'BackgroundColor','white');end%--------------------------------------------------------------------------% --- Executes on button press in window_level.function window_level_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% This Function Does the Window and Level% -------------------------------------------------------------------------% -------------------------------------------------------------------------function imagesc_wl(mtx,scale);% -------------------------------------------%    ctimshow(matrix of ct numbers)% -------------------------------------------   %    Hold the left mouse button & %    move mouse vertically to adjust level %    move mouse horizontally to adjust window%    Level and Window values are displayed on %    screenif (nargin < 2)    if min(min(mtx)) == max(max(mtx))        scale = [min(min(mtx)) max(max(mtx))+0.00001];    else        scale = [min(min(mtx)) max(max(mtx))];    endendf =gcf;% f = figure;imagesc(mtx,scale); %colormap(gray);curr_axes =get(gcf,'CurrentAxes'); axis image; axis off;set( f, 'WindowButtonDownFcn',{@chk_btn_down_local,gcf,gca} );set( f, 'WindowButtonUpFcn', {@chk_btn_up_local,gcf});set(f,'DoubleBuffer','on')function varargout = chk_btn_down_local(obj,eventdata,hfig,haxes)img_hndl = findobj(haxes,'Type','image');if(gco==img_hndl)   set( hfig, 'WindowButtonMotionFcn', {@Move_to_WL_local,hfig,haxes,0});   Move_to_WL_local(gcf,[],hfig,haxes,1);   %[clims(1) clims(2)] = Move_to_WL_local(gcf,[],hfig,haxes,1);    end;function varargout = chk_btn_up_local(obj,eventdata,hfig)set( hfig, 'WindowButtonMotionFcn', '' );    % Make a do-nothing callbackfunction varargout = Move_to_WL_local(obj,eventdata,hfig,haxes,init)  persistent LASTX LASTY  ptr = get(hfig,  'CurrentPoint');  if init == 1    LASTX = ptr(1);    LASTY = ptr(2);        clims = get( haxes, 'CLim');    colorbar('off')    colorbar_handle = colorbar('SouthOutside');    set(colorbar_handle,'Xcolor','k','Ycolor','k','LineWidth',1,'FontSize',12);    set(colorbar_handle,'Position',[0.03 0.09 .5 .05]);    %     varargout(1) = {clims(1)};%     varargout(2) = {clims(2)};          else    dx = ptr(1)-LASTX;    dy = ptr(2)-LASTY;    clims = get( haxes, 'CLim');    colorbar('off')    colorbar_handle = colorbar('SouthOutside');    set(colorbar_handle,'Xcolor','k','Ycolor','k','LineWidth',1,'FontSize',12);    set(colorbar_handle,'Position',[0.03 0.09 .5 .05]);    %     varargout(1) = {clims(1)};%     varargout(2) = {clims(2)};%     handles.clim = clims%     set(handles.clim1,'String',num2str(clims(1)));%     set(handles.clim2,'String',num2str(clims(2)));        win = clims(2)-clims(1);    lev = (clims(1)+clims(2))/2;    %newwin = win- round(2*dx)    %newlev = lev  - round(2*dy)    newwin = win * 10^(dx/400);    newlev = lev - (win*dy)/200;    set(haxes, 'CLim', [newlev-newwin/2 newlev+newwin/2]);    LASTX = ptr(1);    LASTY = ptr(2);    tex = findobj(haxes,'Type','text');    if(~isempty(tex))      delete(tex);    end;%     text(5,15,['L  :',num2str(round(newlev))],'color',[0,0,1]);%     text(5,40,['W :',num2str(round(newwin))],'color',[0,0,1]);      end  %-----------------End Window and Level-------------------------------------%--------------------------------------------------------------------------% executes when new lower limit on colormap is set%--------------------------------------------------------------------------function clim1_Callback(hObject, eventdata, handles)set(handles.colorlock,'Value',1);pushbutton1_Callback(hObject,eventdata,handles);%--------------------------------------------------------------------------% --- Executes during object creation, after setting all properties.function clim1_CreateFcn(hObject, eventdata, handles)%--------------------------------------------------------------------------if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))    set(hObject,'BackgroundColor','white');end%--------------------------------------------------------------------------% executes when new upper limit on colormap is set%--------------------------------------------------------------------------function clim2_Callback(hObject, eventdata, handles)set(handles.colorlock,'Value',1);pushbutton1_Callback(hObject,eventdata,handles);%--------------------------------------------------------------------------% --- Executes during object creation, after setting all properties.function clim2_CreateFcn(hObject, eventdata, handles)%--------------------------------------------------------------------------if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))    set(hObject,'BackgroundColor','white');end%--------------------------------------------------------------------------% --- Executes on button press in colorlock.function colorlock_Callback(hObject, eventdata, handles)% set(handles.clim1,'String',num2str(handles.clim(1)));% set(handles.clim2,'String',num2str(handles.clim(2)));% Novel colormaps% -------------------------------------------------------------------------% -------------------------------------------------------------------------% JET2 is the same as jet but with black basefunction J = jet2(m)if nargin < 1    m = size(get(gcf,'colormap'),1);    J = jet; J(1,:) = [0 0 0];endJ = jet(m); J(1,:) = [0 0 0];% JET3 is the same as jet but with white basefunction J = jet3(m)if nargin < 1    m = size(get(gcf,'colormap'),1);    J = jet; J(1,:) = [1 1 1];endJ = jet(m); J(1,:) = [1 1 1];% HSV2    is the same as HSV but with black basefunction map = hsv2(m)map =hsv;map(1,:) = [0 0 0];% HSV3     is the same as HSV but with white basefunction map = hsv3(m)map =hsv;map(1,:) = [1 1 1];% HSV4    a slight modification of hsv (Hue-saturation-value color map)function map = hsv4(m)if nargin < 1, m = size(get(gcf,'colormap'),1); endh = (0:m-1)'/max(m,1);if isempty(h)  map = [];else  map = hsv2rgb([h h ones(m,1)]);end% -------------------------------------------------------------------------% -------------------------------------------------------------------------% --- Executes on button press in neg.function neg_Callback(hObject, eventdata, handles)%invert colormap popupmenu1_Callback(hObject, eventdata, handles);% --- Executes on button press in timecurve.function timecurve_Callback(hObject, eventdata, handles)% -------------------------------------------------------------------------handles.axes2bit = 1;guidata(hObject, handles);% Load figure dataaxes(handles.axes1);var_name = get(handles.fig, 'String');if strcmp(var_name,'welcome');    data = handles.welcome;else    data = evalin('base',var_name);end% % swap 3 and 4?% if get(handles.perm34,'Value') == 1%     data = permute(data,[1 2 4 3]);% end%perm = evalin('base','perm');perm = handles.perm;data = permute(data,perm);% get volume% nvols=size(data,4);volume=str2double(get(handles.volume,'String'));data = data(:,:,:,volume);% flipdimif get(handles.flip_vert,'Value') == 1    data = flipdim(data,1);endif get(handles.flip_hor,'Value') == 1    data = flipdim(data,2);end% z fourier transformif get(handles.zft,'Value') == 1    data = fft(data,[],3);end% z inverse fourier transformif get(handles.zift,'Value') == 1    data = ifft(data,[],3);end% z fft shiftif get(handles.zftshift,'Value') == 1    data = fftshift(data,3);end% pick the sliceslice = str2double(get(handles.slice,'String'));I = data;%(:,:,slice);% x and y fourier transform if get(handles.xft,'Value') == 1    I = fft(I,[],2);endif get(handles.yft,'Value') == 1    I = fft(I,[],1);end% x and y inverse fourier transform if get(handles.xift,'Value') == 1    I = ifft(I,[],2);endif get(handles.yift,'Value') == 1    I = ifft(I,[],1);end% x and y fft shiftif get(handles.xftshift,'Value') == 1    I = fftshift(I,2);endif get(handles.yftshift,'Value') == 1    I = fftshift(I,1);endmatrix = size(I,1);% radon transform at number of angles = number of columnsif get(handles.radon,'Value') == 1    I = radon(I,[1:size(I,2)]*180/size(I,2));end% inverse radon transform at number of angles = number of columnsif get(handles.iradon,'Value') == 1    I = iradon(I,[1:size(I,2)]*180/size(I,2),'linear','Ram-Lak',1,matrix);end% complex logif get(handles.comp_log,'Value') == 1    I = log(I);    I(find(isnan(I))) = 0;    I(find(isinf(I))) = 0;end% handle complex datan = get(handles.complexdata,'Value');if n == 1; I = real(I); endif n == 2; I = imag(I); endif n == 3; I = abs(I);  endif n == 4; I = angle(I)*180/pi;end;%atan(imag(I)./real(I))*180/pi; end% logif get(handles.natural_log,'Value') == 1    I(find(I>0)) = log(I(find(I>0)));    I(find(I<=0)) = 0;    I(find(isnan(I))) = 0;    I(find(isinf(I))) = 0;end% get the mask of ones defining the ROImask = roipoly_old;% Exclude Zero values if checkbox is onif get(handles.checkbox1,'Value') == 1    maskset = find(mask.*I ~= 0);else    maskset = find(mask > 0);end% set handles.mask as mask and save it so we can use it in other functions% specifically if keepROI is pressed we'll need to retain the ROI so that% when the user pushes display image the same ROI can be used to calculate% std and meanhandles.mask = mask;guidata(hObject, handles);% Calculate std and mean% Plot the histogramaxes(handles.axes2);hold on; box on;% calculate time curves%[mean_1(:,1) std_1(:,1)] = roi_stats(I,mask);[mean_1(:,1) ] = roi_stats(I,mask);% plot time curvesplot(mean_1(:,1),'k','LineWidth',2); hold on;axis tight;% Return to image as active axes set (for roiploy call later)axes(handles.axes1);% -------------------------------------------------------------------------% -------------------------------------------------------------------------function [mea varargout] = roi_stats(data,roi)% -------------------------------------------------------------------------% -------------------------------------------------------------------------% MEA = ROI_STATS(DATA,ROI) returns the MEA (mean) % of an roi when ROI is a binary mask denoting the roi and DATA is a 2d or% 3d data set. %% [MEA SD] = ROI_STATS(DATA,ROI) returns the MEA (mean) and SD (stadard deviation)% of an roi when ROI is a binary mask denoting the roi and DATA is a 2d or% 3d data set.% % if ROI is 3d and DATA is 3d the result is a true 3d roi measurement%% if ROI is 2d and DATA is 3d the result is a an roi measurment of each 2d% slice of data%% if ROI is 2d and DATA is 2d the result is straightforward%% 2-5-07 RO Rafael O'Halloran% -------------------------------------------------------------------------% get dimensionsdim_roi  = length(size(roi));dim_data = length(size(data));% handle 3d and 3d case and  2d 2d caseif dim_data == 3 & dim_roi == 3 | dim_data == 2 & dim_roi == 2    dummy1 = roi(1:end);    dummy2 = data(1:end);    dummy3 = dummy2(find(dummy1 > 0));    if isempty(dummy3)            return    end    mea = mean(dummy3);    varargout(1) = {std(dummy3)};end% handle 3d and 2d caseif dim_data == 3 & dim_roi == 2    for i = 1:size(data,3)       dummy1 = data(:,:,i);       dummy2 = roi(1:end);       dummy3 = dummy1(1:end);       dummy4 = dummy3(find(dummy2 > 0));       if isempty(dummy4)            return       end       mea(i,1) = mean(dummy4);       dummy5(i,1) = std(dummy4);    end        varargout(1) = {dummy5};end% -------------------------------------------------------------------------% -------------------------------------------------------------------------% Clears histogram when 'Clear histogram' is pushed%--------------------------------------------------------------------------function pushbutton7_Callback(hObject, eventdata, handles)axes(handles.axes2);cla; axis auto; axis normal;%--------------------------------------------------------------------------% FOURIER AND RADON STUFF% -------------------------------------------------------------------------% -------------------------------------------------------------------------%  x ft.function xft_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);%  y ft.function yft_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);%  z ft.function zft_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% -------------------------------------------------------------------------%  x ft shift.function xftshift_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);%  y ft shift.function yftshift_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);%  z ft shift.function zftshift_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% -------------------------------------------------------------------------% xift.function xift_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% yift.function yift_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% zift.function zift_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% -------------------------------------------------------------------------% radon.function radon_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% iradon.function iradon_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% natural logfunction natural_log_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% complex valued - natural log (acts on complex and returns complex)function comp_log_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% -------------------------------------------------------------------------% -------------------------------------------------------------------------% Brings up external figurefunction figuredump_Callback(hObject, eventdata, handles)% get the image data[I total_slices] = get_image_data(hObject, eventdata, handles);% clear whatever is in the windowfigure_handle = figure;% display image and select colormap from dropdown menucontents = get(handles.popupmenu1,'String');map = contents{get(handles.popupmenu1,'Value')};% get color limits and set clim boxes if colorlock is offif get(handles.colorlock,'Value') == 0;    clims(1) = min(min(I(:,:,1)));    clims(2) = max(max(I(:,:,1)));    if clims(1)==clims(2)        clims(2)=clims(1)+1;    end    set(handles.clim1,'String',num2str(clims(1)));    set(handles.clim2,'String',num2str(clims(2)));end% set color limits if colorlock is onif get(handles.colorlock,'Value') == 1;    clims(1) = str2num(get(handles.clim1,'String'));    clims(2) = str2num(get(handles.clim2,'String'));end% if window and level is onif get(handles.window_level,'Value') == 1    imagesc_wl(I,[clims(1) clims(2)]); axis tight; axis off; %axis image; elseif get(handles.RGBcolor,'Value') == 1 & total_slices>2    image(I);  axis tight; axis off;else    imagesc(I,[clims(1) clims(2)]); axis tight; axis off; %axis image; endevalin('base','axis image; axis off;');% implement colormapif get(handles.neg,'Value') == 1 && get(handles.Invert,'Value') == 1    evalin('base',['colormap(flipdim(abs(', map , '-1),1))']);elseif get(handles.neg,'Value') == 1    evalin('base',['colormap(abs(', map , '-1))']);elseif get(handles.Invert,'Value') == 1    evalin('base',['colormap(flipdim(',map,',1))']);else    evalin('base',['colormap(',map,')']);enddaspect([str2num(get(handles.aspectratio,'String')) 1 1]);rat = size(I,1)/size(I,2);max_dim = 6;if rat > 1;    row_plot = max_dim;    col_plot = max_dim/rat;else    row_plot = max_dim*rat    col_plot = max_dimendset(gcf,'Units','inches','Position',[1 1 col_plot row_plot]);set(gca, 'Units', 'normalized', 'Position', [0 0  1 1]);axis tight% -------------------------------------------------------------------------% --- Executes on button press in figuredump2.% Not Functional yet, sorry -- Rafaelfunction figuredump2_Callback(hObject, eventdata, handles)%figurelabel = figure;% --- Inverts colormap on button press in Invert.function Invert_Callback(hObject, eventdata, handles)popupmenu1_Callback(hObject, eventdata, handles);% MIP button function MIP_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% --- Executes on button press in globalwl.function globalwl_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% --- Executes on button press in surface.function surface_Callback(hObject, eventdata, handles)% load image dataI = get_image_data(hObject, eventdata, handles);% clear whatever is in the windowfigure_handle = figure;% display image and select colormap from dropdown menucontents = get(handles.popupmenu1,'String');map = contents{get(handles.popupmenu1,'Value')};% get color limits and set clim boxes if colorlock is offif get(handles.colorlock,'Value') == 0;    clims(1) = min(min(I));    clims(2) = max(max(I));    if clims(1)==clims(2)        clims(2)=clims(1)+1;    end    set(handles.clim1,'String',num2str(clims(1)));    set(handles.clim2,'String',num2str(clims(2)));end% set color limits if colorlock is onif get(handles.colorlock,'Value') == 1;    clims(1) = str2num(get(handles.clim1,'String'));    clims(2) = str2num(get(handles.clim2,'String'));end% if window and level is onsurf(I); shading interp;% implement colormapif get(handles.neg,'Value') == 1 && get(handles.Invert,'Value') == 1    evalin('base',['colormap(flipdim(abs(', map , '-1),1))']);elseif get(handles.neg,'Value') == 1    evalin('base',['colormap(abs(', map , '-1))']);elseif get(handles.Invert,'Value') == 1    evalin('base',['colormap(flipdim(',map,',1))']);else    evalin('base',['colormap(',map,')']);end% -------------------------------------------------------------------------% this happens when you push the rgb check box% ------------------------------------------------------------------------function RGBcolor_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% ------------------------------------------------------------------------% Volume text box% ------------------------------------------------------------------------function volume_Callback(hObject, eventdata, handles)volume = str2double(get(hObject, 'String'));pushbutton1_Callback(hObject, eventdata, handles)% ------------------------------------------------------------------------% --- Volume creator.% ------------------------------------------------------------------------function volume_CreateFcn(hObject, eventdata, handles)if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))    set(hObject,'BackgroundColor','white');end% ------------------------------------------------------------------------% --- Cue the volume up button.% ------------------------------------------------------------------------function volume_up_Callback(hObject, eventdata, handles)current_vol = str2num(get(handles.volume,'String'));next_vol = (current_vol + 1);perm = handles.perm% load in size of data array and handle 2d caseif strcmp(get(handles.fig,'String'),'welcome');    array_size = [10 10 1 1];else    array_size = evalin('base',['size(' get(handles.fig,'String') ');']);endif size(array_size) < 4    array_size(4) = 1;elseif size(array_size) < 3    array_size(3) = 1;    array_size(4) = 1;end% calculate highest numbered volumemax_vol = array_size(perm(4));% cue the volume up if one is availableif next_vol <= max_vol    set(handles.volume,'String',num2str(current_vol+1));    pushbutton1_Callback(hObject,eventdata,handles);end% ------------------------------------------------------------------------% --- Cue the volume down button.% ------------------------------------------------------------------------function volume_down_Callback(hObject, eventdata, handles)current_volume = str2num(get(handles.volume,'String'));if current_volume > 1    set(handles.volume,'String',num2str(current_volume-1));    pushbutton1_Callback(hObject,eventdata,handles);end% ------------------------------------------------------------------------% --- Makes spiny movie of stuff.% ------------------------------------------------------------------------function spiny_Callback(hObject, eventdata, handles)nangles = 20;% Load Datavar_name = get(handles.fig, 'String');if strcmp(var_name,'welcome');    data = handles.welcome;else    data = double(evalin('base',var_name));end% get volume% nvols=size(data,4);volume=str2double(get(handles.volume,'String'));data = data(:,:,:,volume);%perm = evalin('base','perm');perm = handles.perm;data = permute(data,perm);% z fourier transformif get(handles.zft,'Value') == 1    data = fft(data,[],3);end% z inverse fourier transformif get(handles.zift,'Value') == 1    data = ifft(data,[],3);end% z fft shiftif get(handles.zftshift,'Value') == 1    data = fftshift(data,3);endI = data;% x and y fourier transform if get(handles.xft,'Value') == 1    I = fft(I,[],2);endif get(handles.yft,'Value') == 1    I = fft(I,[],1);end% x and y inverse fourier transform if get(handles.xift,'Value') == 1    I = ifft(I,[],2);endif get(handles.yift,'Value') == 1    I = ifft(I,[],1);end% x and y fft shiftif get(handles.xftshift,'Value') == 1    I = fftshift(I,2);endif get(handles.yftshift,'Value') == 1    I = fftshift(I,1);endmatrix = size(I,1);% handle complex datan = get(handles.complexdata,'Value');if n == 1; I = real(I); endif n == 2; I = imag(I); endif n == 3; I = abs(I);  endif n == 4; I = angle(I)*180/pi;end;%I = atan(imag(I)./real(I))*180/pi; end% clear whatever is in the window%figure_handle = figure;% display image and select colormap from dropdown menucontents = get(handles.popupmenu1,'String');map = contents{get(handles.popupmenu1,'Value')};% get color limits and set clim boxes if colorlock is offif get(handles.colorlock,'Value') == 0;    clims(1) = min(min(min(I)));    clims(2) = max(max(max(I)));    if clims(1)==clims(2)        clims(2)=clims(1)+1;    end    set(handles.clim1,'String',num2str(clims(1)));    set(handles.clim2,'String',num2str(clims(2)));enddims = size(I);angle_list = [0:2*pi/(nangles):2*pi-2*pi/(nangles)]*180/pi;if length(dims) < 3; dims(3) = 1; endfor i = 1:nangles    for j = 1:dims(3)        mip_list(j,:,i) = radon(I(:,:,j), angle_list(i) );        end    disp(['working on angle ' blanks(1) num2str(i)]);endvideo(mip_list, 8, 4, [min(min(min(mip_list))) max(max(max(mip_list)))])% ------------------------------------------------------------------------function varargout = roipoly_old(varargin)%ROIPOLY Select polygonal region of interest.%   Use ROIPOLY to select a polygonal region of interest within an%   image. ROIPOLY returns a binary image that you can use as a mask for%   masked filtering.%%   BW = ROIPOLY(I,C,R) returns the region of interest selected by the polygon%   described by vectors C and R. BW is a binary image the same size as I with%   0's outside the region of interest and 1's inside.%%   BW = ROIPOLY(I) displays the image I on the screen and lets you specify%   the polygon using the mouse. If you omit I, ROIPOLY operates on the image%   in the current axes. Use normal button clicks to add vertices to the%   polygon. Pressing <BACKSPACE> or <DELETE> removes the previously selected%   vertex. A shift-click, right-click, or double-click adds a final vertex to%   the selection and then starts the fill; pressing <RETURN> finishes the%   selection without adding a vertex.%%   BW = ROIPOLY(x,y,I,xi,yi) uses the vectors x and y to establish a%   nondefault spatial coordinate system. xi and yi are equal-length vectors%   that specify polygon vertices as locations in this coordinate system.%%   [BW,xi,yi] = ROIPOLY(...) returns the polygon coordinates in xi and%   yi. Note that ROIPOLY always produces a closed polygon. If the points%   specified describe a closed polygon (i.e., if the last pair of coordinates%   is identical to the first pair), the length of xi and yi is equal to the%   number of points specified. If the points specified do not describe a%   closed polygon, ROIPOLY adds a final point having the same coordinates as%   the first point. (In this case the length of xi and yi is one greater than%   the number of points specified.)%%   [x,y,BW,xi,yi] = ROIPOLY(...) returns the XData and YData in x and y; the%   mask image in BW; and the polygon coordinates in xi and yi.%%   If ROIPOLY is called with no output arguments, the resulting image is%   displayed in a new figure.%%   Class Support%   -------------%   The input image I can be uint8, uint16, int16, single or double.  The%   output image BW is logical. All other inputs and outputs are double.%%   Remarks%   -------%   For any of the ROIPOLY syntaxes, you can replace the input image I with%   two arguments, M and N, that specify the row and column dimensions of an%   arbitrary image. If you specify M and N with an interactive form of%   ROIPOLY, an M-by-N black image is displayed, and you use the mouse to%   specify a polygon with this image.%%   Example%   -------%       I = imread('eight.tif');%       c = [222 272 300 270 221 194];%       r = [21 21 75 121 121 75];%       BW = roipoly(I,c,r);%       figure, imshow(I), figure, imshow(BW)%%   See also POLY2MASK, ROIFILT2, ROICOLOR, ROIFILL.%   Copyright 1993-2004 The MathWorks, Inc.%   $Revision: 5.27.4.6 $  $Date: 2004/08/10 01:46:40 $[xdata,ydata,num_rows,num_cols,xi,yi] = parse_inputs(varargin{:});if length(xi)~=length(yi)    eid = sprintf('Images:%s:xiyiMustBeSameLength',mfilename);    error(eid,'%s','XI and YI must be the same length.'); end% Make sure polygon is closed.if (~isempty(xi))    if ( xi(1) ~= xi(end) || yi(1) ~= yi(end) )        xi = [xi;xi(1)];         yi = [yi;yi(1)];    endend% Transform xi,yi into pixel coordinates.roix = axes2pix(num_cols, xdata, xi);roiy = axes2pix(num_rows, ydata, yi);d = poly2mask(roix, roiy, num_rows, num_cols);switch nargoutcase 0    figure    if (~isequal(xdata, [1 size(d,2)]) || ~isequal(ydata, [1 size(d,1)]))        imshow(d,'XData',xdata,'YData',ydata);  % makes tick labels visible    else        imshow(d)    end    case 1    varargout{1} = d;    case 2    varargout{1} = d;    varargout{2} = xi;    case 3    varargout{1} = d;    varargout{2} = xi;    varargout{3} = yi;    case 4    varargout{1} = xdata;    varargout{2} = ydata;    varargout{3} = d;    varargout{4} = xi;    case 5    varargout{1} = xdata;    varargout{2} = ydata;    varargout{3} = d;    varargout{4} = xi;    varargout{5} = yi;    otherwise    eid = sprintf('Images:%s:tooManyOutputArgs',mfilename);    error(eid,'%s','Too many output arguments');    end%%%%%% parse_inputs%%%function [x,y,nrows,ncols,xi,yi] = parse_inputs(varargin)switch nargincase 0,     % ROIPOLY    %  Get information from the current figure    [x,y,a,hasimage] = getimage;    if ~hasimage,        eid = sprintf('Images:%s:needImageInFigure',mfilename);        error(eid,'%s',...              'The current figure must contain an image to use ROIPOLY.');    end    [xi,yi] = getline(gcf,'closed'); % Get rect info from the user.    nrows = size(a,1);    ncols = size(a,2);    case 1    % ROIPOLY(A)    a = varargin{1};    nrows = size(a,1);    ncols = size(a,2);    x = [1 ncols];    y = [1 nrows];    imshow(a);    [xi,yi] = getline(gcf,'closed');    case 2    % ROIPOLY(M,N)    nrows = varargin{1};    ncols = varargin{2};    a = repmat(uint8(0), nrows, ncols);    x = [1 ncols];    y = [1 nrows];    imshow(a);    [xi,yi] = getline(gcf,'closed');    case 3,    % SYNTAX: roipoly(A,xi,yi)    a = varargin{1};    nrows = size(a,1);    ncols = size(a,2);    xi = varargin{2}(:);    yi = varargin{3}(:);    x = [1 ncols]; y = [1 nrows];case 4,    % SYNTAX: roipoly(m,n,xi,yi)    nrows = varargin{1};     ncols = varargin{2};    xi = varargin{3}(:);    yi = varargin{4}(:);    x = [1 ncols]; y = [1 nrows];    case 5,    % SYNTAX: roipoly(x,y,A,xi,yi)    x = varargin{1};     y = varargin{2};     a = varargin{3};    xi = varargin{4}(:);     yi = varargin{5}(:);    nrows = size(a,1);    ncols = size(a,2);    x = [x(1) x(end)];    y = [y(1) y(end)];    case 6,    % SYNTAX: roipoly(x,y,m,n,xi,yi)    x = varargin{1};     y = varargin{2};     nrows = varargin{3};    ncols = varargin{4};    xi = varargin{5}(:);     yi = varargin{6}(:);    x = [x(1) x(end)];    y = [y(1) y(end)];    otherwise,    eid = sprintf('Images:%s:invalidInputArgs',mfilename);    error(eid,'%s','Invalid input arguments.');endxi = cast_to_double(xi);yi = cast_to_double(yi);x = cast_to_double(x);y = cast_to_double(y);nrows= cast_to_double(nrows);ncols = cast_to_double(ncols);%%%% cast_to_double%%%function a = cast_to_double(a)  if ~isa(a,'double')    a = double(a);  endfunction dummy_out = video(data,fps,plays,data_range)% ------------------------------------------------------------------------% VIDEO(DATA,FPS,PLAYS,DATA_RANGE) plays the frames in the 3d array % % INPUT% -------------------------------------------------------------------------% DATA          The three-d data to play each x-y slice is a frame% FPS           play speed in frames per second% PLAYS         Times to loop though movie% DATA_RANGE    max and min colorscale values to play (ie [0 1])% -------------------------------------------------------------------------if nargin == 1    fps = 1;    plays = 1;    data_range = [0 max(max(max(data)))];elseif nargin == 2    plays = 1;    data_range = [0 max(max(max(data)))];elseif nargin == 3     data_range = [0 max(max(max(data)))];endnumframes = size(data,3);%figure; set(gcf,'Units','Pixels','Position',[0, 0, 1024, 1024]); figure; set(gcf,'Units','Normalized','Position',[0, 0, 1, 1]); for j=1:numframes          imagesc(data(:,:,j),data_range); axis off; axis equal; axis image;          %imagesc(data(:,:,j)); axis off; axis equal; axis image; axis tight;          colormap jet;          %colormap(abs(hot-1));          M(j) = getframe;endmovie(M,plays,fps)% Zoom out% -------------------------------------------------------------------------function zoom_out_Callback(hObject, eventdata, handles)axes(handles.axes1);pushbutton1_Callback(hObject, eventdata, handles);% -------------------------------------------------------------------------% Zoom in% -------------------------------------------------------------------------function zoom_in_Callback(hObject, eventdata, handles)axes(handles.axes1);zoom; % -------------------------------------------------------------------------% flip image vertically% ------------------------------------------------------------------------function flip_vert_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% ------------------------------------------------------------------------% flip image horizontally% ------------------------------------------------------------------------function flip_hor_Callback(hObject, eventdata, handles)pushbutton1_Callback(hObject,eventdata,handles);% ------------------------------------------------------------------------% swap index 3 with index 4% ------------------------------------------------------------------------function perm34_Callback(hObject, eventdata, handles)permu_Callback(hObject, eventdata, handles);%pushbutton1_Callback(hObject,eventdata,handles);% ------------------------------------------------------------------------% Output figures for publications. Upsampled by factor of 2function figuredump_pub_Callback(hObject, eventdata, handles)% -------------------------------------------------------------------------% get the image data[I total_slices] = get_image_data(hObject, eventdata, handles);size(I)% upsample that dataI = rafael_sample(I,2,1,2);% clear whatever is in the windowfigure_handle = figure;% display image and select colormap from dropdown menucontents = get(handles.popupmenu1,'String');map = contents{get(handles.popupmenu1,'Value')};% get color limits and set clim boxes if colorlock is offif get(handles.colorlock,'Value') == 0;    clims(1) = min(min(I(:,:,1)));    clims(2) = max(max(I(:,:,1)));    if clims(1)==clims(2)        clims(2)=clims(1)+1;    end    set(handles.clim1,'String',num2str(clims(1)));    set(handles.clim2,'String',num2str(clims(2)));end% set color limits if colorlock is onif get(handles.colorlock,'Value') == 1;    clims(1) = str2num(get(handles.clim1,'String'));    clims(2) = str2num(get(handles.clim2,'String'));end% if window and level is onif get(handles.window_level,'Value') == 1    imagesc_wl(I,[clims(1) clims(2)]); axis tight; axis off; %axis image; elseif get(handles.RGBcolor,'Value') == 1 & total_slices>2    I(find(I<0)) = 0;    I(find(I>1)) = 1;    image(I);  axis tight; axis off;else    imagesc(I,[clims(1) clims(2)]); axis tight; axis off; %axis image; endevalin('base','axis image; axis off;');% implement colormapif get(handles.neg,'Value') == 1 && get(handles.Invert,'Value') == 1    evalin('base',['colormap(flipdim(abs(', map , '-1),1))']);elseif get(handles.neg,'Value') == 1    evalin('base',['colormap(abs(', map , '-1))']);elseif get(handles.Invert,'Value') == 1    evalin('base',['colormap(flipdim(',map,',1))']);else    evalin('base',['colormap(',map,')']);enddaspect([str2num(get(handles.aspectratio,'String')) 1 1]);rat = size(I,1)/size(I,2);max_dim = 6;if rat > 1;    row_plot = max_dim;    col_plot = max_dim/rat;else    row_plot = max_dim*rat    col_plot = max_dimendset(gcf,'Units','inches','Position',[1 1 col_plot row_plot]);set(gca, 'Units', 'normalized', 'Position', [0 0  1 1]);axis tight% -------------------------------------------------------------------------